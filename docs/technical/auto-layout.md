# Auto-Layout — Автоматическое выравнивание карточек

## Описание

Auto-Layout автоматически выстраивает карточки (лицензии) в аккуратное бинарное дерево без наложений. Функция анализирует connections (линии связей) от выбранной корневой карточки и рассчитывает оптимальные позиции для всех связанных карточек.

## Расположение файлов

| Файл | Назначение |
|------|-----------|
| `src/utils/autoLayout.js` | Основной алгоритм раскладки (чистая функция) |
| `src/components/Layout/HeaderActions.vue` | Кнопка Auto-Layout в десктопном тулбаре |
| `src/components/Layout/MobileSidebar.vue` | Кнопка Auto-Layout в мобильном sidebar |
| `src/App.vue` | Обработчик `handleAutoLayout` для MobileSidebar |
| `src/locales/ru.js`, `en.js`, `zh.js` | i18n переводы |

## Как использовать

### Пошаговая инструкция

1. **Выберите корневую карточку** — кликните на карточку, которая должна стать вершиной дерева
2. **Нажмите кнопку ⊞** (Авто-раскладка) в тулбаре
3. Система автоматически выстроит все связанные карточки в бинарное дерево
4. Для отмены нажмите **Ctrl+Z**

### Режимы работы

#### Режим 1 — Полное дерево
- Выделена **одна карточка** (корень)
- Перестраиваются **все карточки**, достижимые от этого корня по connections
- Карточки без связей с корнем не затрагиваются

#### Режим 2 — Только выделенные
- Выделено **несколько карточек** (Shift+клик или область выделения)
- Перестраиваются **только выделенные карточки** и connections между ними
- Корень определяется автоматически — карточка с наименьшим числом входящих connections

## Технические детали

### Экспортируемые функции

#### `calculateAutoLayout({ rootId, cards, connections, options })`

Основная функция расчёта позиций. Чистая функция без зависимостей от Vue/Pinia.

**Параметры:**
- `rootId` (string) — ID корневой карточки
- `cards` (Array) — массив карточек `[{ id, x, y, width, height, type, ... }]`
- `connections` (Array) — массив соединений `[{ id, from, to, fromSide, toSide, ... }]`
- `options` (Object, необязательно) — настройки раскладки

**Возвращает:**
```javascript
{
  positions: Map<string, { x: number, y: number }>,  // Новые позиции
  affectedCardIds: string[]                            // ID затронутых карточек
}
```

#### `findRootAmongSelected(selectedCards, connections)`

Находит корневую карточку среди выделенных. Корень — карточка с наименьшим количеством входящих connections. При равном количестве предпочитается тип `large`.

**Параметры:**
- `selectedCards` (Array) — массив выделенных карточек
- `connections` (Array) — соединения между выделенными карточками

**Возвращает:** `string|undefined` — ID корневой карточки

### Алгоритм

#### Шаг A — Построение дерева (двунаправленный обход)

Из массива connections строится **двунаправленный граф смежности** (adjacency list). Каждая карточка знает обо ВСЕХ своих connections — и как `from`, и как `to`.

**Почему двунаправленный?** Межтреугольные связи (когда к нижней карточке одного треугольника прикреплён корень вложенного треугольника) могут быть записаны в обратном направлении: `from` = ребёнок (нижний), `to` = родитель (верхний). Однонаправленный обход по `from` не находит такие связи.

**BFS от корня:**
1. Для текущей карточки берём ВСЕ рёбра из adjacency list
2. Если сосед ещё не посещён → он ребёнок, текущая карточка — родитель
3. Сторона определяется по `mySide` (сторона текущей/родительской карточки):
   - `"left"` → левый ребёнок
   - `"right"` → правый ребёнок
   - `"top"`, `"bottom"` → на первую свободную сторону
4. Защита от циклов через Set visited

#### Шаг B — Вычисление ширин поддеревьев (bottom-up)
```
subtreeWidth(лист) = card.width
subtreeWidth(узел) = max(card.width, leftWidth + horizontalGap + rightWidth)
```

#### Шаг C — Расчёт позиций (children-first, then center parent)
Рекурсивное назначение позиций. Сначала размещаются дети, затем родитель центрируется **между центрами непосредственных детей** (а не в пределах subtreeWidth). Это гарантирует визуально правильное положение родителя над детьми даже при асимметричных поддеревьях.

#### Шаг D — Нормализация координат
Смещение всех позиций так, чтобы корень остался на прежнем месте:
```
offsetX = originalRoot.x - calculatedRoot.x
offsetY = originalRoot.y - calculatedRoot.y
```

## Настройки

| Параметр | По умолчанию | Описание |
|----------|-------------|----------|
| `horizontalGap` | 50 | Минимальный горизонтальный зазор между карточками (px) |
| `verticalGap` | 80 | Вертикальный зазор между уровнями дерева (px) |

## Размеры карточек

| Тип | Ширина | Высота |
|-----|--------|--------|
| `large` | 600 | 400 |
| `gold` | 600 | 400 |
| `small` | 400 | 300 |
| `user_card` | diameter | diameter |

## Граничные случаи

| Случай | Поведение |
|--------|----------|
| Одна карточка без connections | Ничего не происходит (positions пуст) |
| Циклические связи | Set visited предотвращает бесконечный обход |
| Карточка с >2 детьми на одной стороне | Дополнительные дети выстраиваются цепочкой |
| Шаблоны КЛИН/ЦЕПЬ (`fromSide: "bottom"`) | Ребёнок подвешивается на первую свободную сторону |
| Вложенные треугольники (межтреугольные связи) | Двунаправленный обход находит все связи |
| Несколько деревьев на доске | Перестраивается только дерево выбранного корня |
| Доска в режиме readonly | Кнопка заблокирована, раскладка не применяется |

## История изменений

- **2026-02-18** — Создание модуля Auto-Layout
- **2026-02-18** — Исправление обхода дерева: переход на двунаправленный adjacency list для поддержки вложенных структур (межтреугольные связи)
- **2026-02-18** — Исправление центровки: родитель теперь центрируется между центрами непосредственных детей, а не в пределах subtreeWidth
